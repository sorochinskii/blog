---
title: "Указатели в Python"
date: 2021-08-06 00:00:00 -0000
categories: 
  - blog
tags:
  - python
  - pointers
  - translation
---
---

[Оригинальный текст Pointers in Python: What's the Point?](https://realpython.com/pointers-in-python/)

## Почему в Питоне нет указателей?

Я не знаю. Могут ли указатели существовать нативно? Возможно, но тогда придется пойти против  [Zen of Python](https://www.python.org/dev/peps/pep-0020/#id3), поощряя неявные изменения (вместо явных) и усложняя простоту. Также вполне можно прострелить ногу, например, получив доступ к данным в участке памяти, который вообще-то не для вас, молодой человек.

Абстрагирование от деталей реализации и удобство использования (даже в ущерб скорости) это одни из  преимуществ Python, поэтому указатели не имеют смысла. Хотя некоторые выгоды указателей Python все же предоставляет.

Для понимания указателей в Python требуется небольшое погружение в реализацию языка. Особенно необходимо понять:

1. Изменяемость/неизменяемость объектов.
2. Переменные/имена.

## Объекты в Python

Все объект

```python
>>> a = 1
>>> print(isinstance(a, object))
True
>>> print(isinstance('string', object))
True
>>> print(isinstance([1, 2, 3], object))
True
>>> print(isinstance(type, object))
True
>>> print(isinstance(True, object))
True
>>> print(isinstance(None, object))
True
>>> print(isinstance(open('text.txt', 'w'), object))
True
```

Код выше можно было бы продолжить, но просто доверимся утверждению "все является объектом". 
Каждый объект должен содержать минимум три составляющих:

- [cчетчик ссылок](https://docs.python.org/3/library/sys.html#sys.getrefcount)  необходим для управления памятью. Для более глубокого ознакомления с управлением памятью в Python предлагается статья [Memory Management in Python](https://realpython.com/python-memory-management/).
- тип используется на уровне [CPython](https://realpython.com/products/cpython-internals-book/) для обеспечения безопасности во время исполнения. 
- значение - собственно значение, которое ассоциируется с объектом.

## Изменяемость объектов

В разрезе изменяемости, объекты могут быть

1. **неизменяемые**
2. **изменяемые**

Понимание разницы этих двух характеристик объектов - первый ключ к пониманию указателей. Ниже показаны типы данных и их изменяемость.

| Тип         | **Не**изменяемый? |
| ----------- | ----------------- |
| `int`       | Да                |
| `float`     | Да                |
| `bool`      | Да                |
| `complex`   | Да                |
| `tuple`     | Да                |
| `frozenset` | Да                |
| `str`       | Да                |
| `list`      | Нет               |
| `set`       | Нет               |
| `dict`      | Нет               |

Из таблицы видно, что примитивные типы неизменяемые [immutable](https://realpython.com/courses/immutability-python/). Для исследования изменяемости объектов можно использовать пару функций из стандартной библиотеки Python:

1. **`id()`** возвращает адрес объекта в памяти
2. **`is`** возвращает `True` только когда два объекта имеют один и тот же адрес памяти.

Например,

````python

>>> a = 1
>>> id(a)
9788608

````

Теперь, если изменить изменить значение `x`, получим новый объект

```python

>>> a += 1
>>> a
2
>>> id(a)
9788640
```

Несмотря на то, что вышеприведенный код изменяет только значение, в итоге возвращается **новый** объект.

Тип `str` также неизменяемый:

```python
>>> s = "Чип"
>>> id(s)
140477826167984
>>> s += " и Дейл"
>>> s
'Чип и Дейл'
>>> id(s)
140477826167888

```

И снова, `s` оказывается по другому адресу в памяти после операции `+=`.

**Дополнение:** оператор `+=` транслируется в вызов различных методов. Для объектов типа [`list`](https://realpython.com/python-lists-tuples/), `+=` будет транслироваться в  `__iadd__()` (in-place add (сложение на месте)). Эта операция модифицирует `self` и вернет тот же ID. Тем не менее, `str` и `int` не имеют этих методов и вызывают  `__add__()`  вместо `__iadd__()`.Для большей информации посмотрите [модель данных Python.](https://docs.python.org/3/reference/datamodel.html#object.__iadd__)

Попытка непосредственно изменить строку вернется ошибкой:

```python
>>> s[0] = "y"
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'str' object does not support item assignment
```

Эта ошибка говорит о том, что `str` не поддерживает такое модифицирование, что подходит под определение того, что тип `str` неизменяемый.

В отличие от изменяемых объектов, например, `list`:

```python
>>> l = [1, 2, 3]
>>> id(l)
139696413115392
>>> l += [4, 5]
>>> l
[1, 2, 3, 4, 5]
>>> id(l)
139696413115392
```

Как видим, адрес памяти списка `l` не изменился после изменения значения по причине того, что тип `list` изменяемый.

Такой же результат будет для следующего кода:

```python
>>> l = [1, 2, 3]
>>> id(l)
139696413115392
>>> l[0] = 0
>>> id(l)
139696413115392
```

Даже изменив первый элемент переменной списка `l`, ее адрес не изменился.

Следующим шагом в разборе [не]изменяемости станет понимание экосистемы переменных Python.

## Разбираемся с переменными

Переменные Python основательно отличаются от переменных C, C++. Вообще, в Python нет переменных - *Python имеет имена, а не переменные*, что может показаться педантичным утверждением. Хотя удобнее думать о именах в Python как переменных, но само понимание разницы очень важно. Особенно когда пытаешься разобраться в указателях.

Для понимания разницы можно посмотреть как работают переменные в C, что они из себя представляют, а затем посмотреть как работают имена в Python.

### Переменные в C

Возьмем код, в котором определяется переменная `x`:

```c
int x = 2337;
```

При выполнении этой строки кода, выполняются следующие операции:

1. Выделяется ячейка памяти для целого числа (integer)
2. В эту ячейку записывается значение `2337`
3. Indicate that `x` points to that value.

Содержимое памяти упрощенно показано на картинке:

![https://files.realpython.com/media/c_memory1.334fe7c13e82.png](https://files.realpython.com/media/c_memory1.334fe7c13e82.png)

На картинке показано, что переменная `x` имеет фальшивый адрес памяти `0x7f1` и значение `2337`. Если в программе потребуется изменить значение переменной `x`, просто можно сделать следующее

```c
x = 2338;
```

Этот код присваивает новое значение переменной `x`, тем самым ***переписывая*** предыдущее значение. Это означает, что **переменная `x` изменяемая**. Измененное состояние памяти показывает новое значение:

![](https://files.realpython.com/media/c_memory2.14d638daf718.png)

Обращаем внимание, что адрес (location) переменной `x` не поменялся, изменилось только значение. В каком-то смысле, переменной `x` принадлежит ячейка памяти, это пустая коробка, которая может уместить только одно целое число и в которой значение этого числа может храниться.

Когда присваиваешь значение переменной `x`, ты помещаешь значение в коробку, которая принадлежит `x`. Давайте введем новую переменную `y`:

```c
int y = x;
```

Этот код создает **новую** коробку называемую `y` и копирует значение из коробки `x` в коробку `y`. Теперь размещения в памяти выглядят так:

![](https://files.realpython.com/media/c_memory3.5afe110faf4d.png)

Обращаем внимание на адрес новой ячейки `0x7f5` переменной `y`. Несмотря на то, что значение `x` было скопировано в `y`, переменная `y` имеет совсем другой адрес в памяти. Поэтому теперь возможно изменить значение `y` не влияя на значение `x`:

```c
y = 2339;
```

Теперь размещения в памяти выглядят следующим образом:

![](https://files.realpython.com/media/c_memory4.45a45dbbfaab.png)

Еще раз, *изменение* *значения `y` не влечет изменение расположения в памяти*. В дополнение к этому, никакого влияния на переменную `x` оказано не было. Это абсолютное отличие от имен переменных в Python.

### Имена в Python

Python не имеет перменных, он имеет имена. Несмотря на это, никто не запрещает использовать термин "переменная". Но понимание различий между переменными и именами важно.

Используем примера для языка C в переложении на Python:

```python
>>> x = 2337
```

Как и в C, этот код исполняется в несколько шагов во время исполнения:

1. Создание `PyObject`
2. Установление типа int для `PyObject`
3. Установление значения `2337` для `PyObject`
4. Создание имени `x`
5. Увеличение счетчика ссылок объекта `PyObject` на единицу

**Замечание:**  [`PyObject`](https://github.com/python/cpython/blob/v3.7.3/Include/object.h#L101) не то же самое, что `object`. Он специфичен для СPython и представляет основную структуру для всех объектов Python.

`PyObject` определен также как структура C, поэтому если поинтересоваться, почему нельзя вызвать `typecode` или `refcount` непосредственно, ответ будет - потому непосредственного доступа к структурам нет. Вызов метода [`sys.getrefcount()`](https://docs.python.org/3/library/sys.html#sys.getrefcount) может помочь получить немножко внутренностей.

Размещение в памяти может быть похоже на:

![](https://files.realpython.com/media/py_memory1.2b6e5f8e5bc9.png)

Как видно, распределение в памяти абсолютно отличается от вышеприведенных примеров на C. Вместо переменной `x` владеющей ячейкой памяти, хранящей значение  `2337`, созданный объект Python владеет памятью, в которой `2337` находится. Имя `x` непосредственно не указывает ни на какую ячейку памяти, как это происходит в C.

Присвоим новое значение `x`:

```python
>>> x = 2338
```

Теперь последовательность действий будет отличаться от эквивалентного кода C, но не намного от первоначального присваивания на Python:

1. Создание нового `PyObject`
2. Установка типа int для `PyObject`
3. Установка значения `2338` для нового `PyObject`
4. Привязка `x` к новому `PyObject`
5. Увеличение счетчика ссылок нового `PyObject` на единицу
6. Уменьшение счетчика ссылок старого `PyObject` на единицу.

Теперь расположение в памяти выглядит так:

![](https://files.realpython.com/media/py_memory2.99bb432c3432.png)

Схема на картинке иллюстрирует что `x` указывает на ссылку на объект, который не владеет той же областью памяти как раньше. Также показано, что `x = 2338` не является присвоением, а скорее связывает имя `x` со ссылкой.

В дополнение, предыдущий объект (который хранил значение `2337`) сейчас находится в памяти со счетчиком ссылок равным 0 и будет очищен [сборщиком мусора](https://docs.python.org/3/faq/design.html?highlight=garbage%20collect#how-does-python-manage-memory).

Укажем новое имя `y`, так же как в примере для C:

```python
>>> y = x
```

В памяти расположится новое имя, но не обязательно новый объект:

![](https://files.realpython.com/media/py_memory3_1.ea43471d3bf6.png)

Можно увидеть, что новый объект Python не создавался, а просто новое имя указывает на старый объект. Также счетчик ссылок этого объекта увеличился на единицу. Можно проверить, сравнив объекты:

```python
>>> y is x
True
```

Код выше демонстрирует что `x` и `y` один и тот же объект. Но расслабляться не стоит: `y` остается неизменяемым.

Например, можно изменить значение `y` сложением:

```python
>>> y += 1
>>> y is x
False
```

После вызова сложения, возвратится новы объект и распределение в памяти будет выглядeть следующим образом:

![](https://files.realpython.com/media/py_memory4.0a15e8415a15.png)

Новый объект создался и `y` теперь указывает на него. Примечательно, что если бы `2339` напрямую был присвоен `y`, результат был бы таким же.

```python
>>> y = 2339
```

Код выше приведет к такому же состоянию памяти, как и в случае сложения. 

Подведем итог - в Python не присваиваются значения переменным, а привязываются имена к ссылкам.

### Замечание по внутреннему устройству объектов в Python

Когда стало понятно как объекты создаются и имена привязываются к этим объектам, время вставить палку в колесо. Этой палкой являются интернированные объекты.

Предположим, имеется следующий код:

```python
>>> x = 1000
>>> y = 1000
>>> x is y
True
```

Видно, что `x` и `y` являются именами одного и того же объекта. Но объект Python, содержащий значение `1000` не всегда имеет один и тот же адрес в памяти. Например, если сложить два числа, чтобы получилось значение `1000`, объект будет иметь другой адрес в памяти:

```python
>>> x = 1000
>>> y = 499 + 501
>>> x is y
False
```

В этот раз `x is y` вернет `False`. Если это непонятно, не надо беспокоиться. Вот последовательность действий, которые происходят во время выполнения кода:

1. Создание объекта (`1000`)
2. Назначение имени `x` объекту
3. Создание объекта (`409`)
4. Создание объекта (`501`)
5. Сложение этих двух объектов
6. Привязывание имени `y` этому объекту.

**Техническое замечание:** эта последовательность будет такой, если код будет выполняться в REPL (или в shell). Если взять этот код, вставить в файл и выполнить, то `x is y` вернет `True`. Это произойдет, потому что компиляторы умны. Компилятор CPython попытается выполнить **peephole**-оптимизацию, которая поможет уменьшить количество действий насколько возможно. Для более детальной информации можно попробовать посмотреть [CPython’s peephole optimizer source code](https://github.com/python/cpython/blob/main/Python/compile.c).

Разве это не затратно? Конечно. Но за эту цены получаем великие преимущества Python. Программисту не надо заботиться об удалении промежуточных объектов или даже вообще знать о их существовании. Наслаждение в том, что эти операции относительно быстры и знать о них не было необходимости. До текущего момента.

Основные разработчики Python настолько преисполнились в своей мудрости, что решили снизить эти затраты с помощью нескольких оптимизаций. Результаты этих оптимизаций могут сбить с толку новичков:

```python
>>> x = 20
>>> y = 19 + 1
>>> x is y
True
```

Этот код похож на предыдущий пример, но результат выполнения `True`. Это является результатом интернирования объектов. Python заранее создает определенное количество объектов в памяти и хранит их в глобальном [неймспейсе](https://realpython.com/python-namespaces-scope/) для регулярного использования.

Какие объекты зависят от реализации Python. CPython 3.7 интернирует следующие объекты:

1. Целые числа между `-5` и `256`
2. Строки содержащие только ASCII букву, цифру или знак подчеркивания.

Интернирую эти объекты, Python предотвращает излишнее выделение памяти для постоянно используемых объектов.

Строки из менее чем 20 символов и содержащие ASCII буквы, цифры или знаки подчеркивания будут интернированы. ~~Причина этого в том, что~~ 

```python
>>> s1 = "some string"
>>> s2 = "some string"
>>> s1 is s2
False
>>> s1 = "somestring"
>>> s2 = "somestring"
>>> s1 is s2
True
>>> s1 = "some_string"
>>> s2 = "some_string"
>>> s1 is s2
True
```

Этот код показывает, что использование символа *пробел*, который не входят в вышеописанный список интернирования, приводит к тому, что объекты становятся действительно разными в памяти.

**Дополнение:** существует возможность принудительного интернирования объектов с помощью функции `sys.intern()`. Один из случаев использования этой функции описан в документации:

> Интернированные строки полезны для повышения производительности поиска в словарях - если ключи в словаре интернированы и искомый ключ интернирован, сравнение ключей (после хэширования) может быть сделано сравнением указателей вместо сравнения строк. 

Интернированные объекты могут быть источником путаницы. Чтобы всегда быть уверенным, в случае сомнения всегда можно использовать `id()` и `is` для определения равенства.

## Симулирование указателей в Python

Несмотря на отсутствие указателей в Python, возможно получить некоторые преимущества используя указатели. Есть множество возможностей симулирования указателей. В этом разделе будут описаны два из них:

1. Использование изменяемых типов как указателей
2. Использование пользовательских объектов

### Использование изменяемых типов как указателей

Нам уже немного знакомы изменяемые типы. Из-за изменяемости, существует возможность использовать такие объекты как если бы они были указателями. Например, хочется повторить следующий C-код:

```python
void add_one(int *x) {
    *x += 1;
}
```

Этот код принимает указатель на целое число (`*x`) и затем увеличивает значение числа на единицу.  Вот пример main-функции для примера:

```python
#include <stdio.h>

int main(void) {
    int y = 2337;
    printf("y = %d\n", y);
    add_one(&y);
    printf("y = %d\n", y);
    return 0;
}
```

В этом коде `y` присваивается `2337`, затем печатается текущее значение, потом увеличивается значение на единицу (`add_one(&)`) и затем печатается результирующее число.

```python
y = 2337
y = 2338
```

Попробуем первый способ симулирования поведения указателей. Рассмотрим использование списка и изменения первого элемента:

```python
>>> def add_one(x):
...     x[0] += 1
...
>>> y = [2337]
>>> add_one(y)
>>> y[0]
2338
```

В этом примере `add_one(x)` получает первый элемент, увеличивает его на единицу и возвращает.  Использование списка подразумевает что конечный результат оказывается измененным значением  элемента этого списка. Так как тип `list` изменяемый, приведенный выше код сработал без ошибок. Но если тот же код попробовать с типом `tuple`, возникнет ошибка:

```python
>>> z = (2337,)
>>> add_one(z)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 2, in add_one
TypeError: 'tuple' object does not support item assignment
```

Этот код демонстрирует, что кортеж не изменяемый. Следовательно, кортеж не поддерживает добавление элементов. Другая возможность имитировать указатели это использование типа `dict`. 

Представим, что есть приложение, которое должно отслеживать момент времени, в который что-либо произошло. Для этого будем использовать словарь и один из его элементов будет счетчиком:

```python
>>> counters = {"func_calls": 0}
>>> def bar():
...     counters["func_calls"] += 1
...
>>> def foo():
...     counters["func_calls"] += 1
...     bar()
...
>>> foo()
>>> counters["func_calls"]
2
```

В этом примере, словарь `counters` используется для хранения количества вызовов функции. После вызова `foo()`,  ожидается, что счетчик увеличится на две единицы. Этот пример работает, потому что объект типа `dict` изменяемый.

Держите в голове, что это были лишь имитации поведения указателе и напрямую к настоящим указателям C/C++ не относятся.  То есть эти операции намного затратнее чем они могли бы быть в C/C++.

### Использование объектов Python

Использование словаря хороший способ эмулировать указатели, но иногда утомительно запоминать имя используемого ключа. Особенно если использовать словарь в различных частях приложения. В этом случае может помочь собственный класс Python.

Продолжим последний пример и предположим, что стоит задача отслеживать метрики в приложении. Создание класса отличный способ абстрагироваться от деталей:

```python
class Metrics(object):
    def __init__(self):
        self._metrics = {
            "func_calls": 0,
            "cat_pictures_served": 0,
        }
```

Этот код определяет класс `Metrics`. Этот класс использует словарь для хранения актуальных данных, который находятся в переменной `_metrics`. Это даст изменяемость, которая так нужна. Далее необходимо просто иметь доступ к этой переменной. Хороший способ это сделать - использовать  [`@property`](https://docs.python.org/3/library/functions.html#property):

```python
class Metrics(object):
    # ...

    @property
    def func_calls(self):
        return self._metrics["func_calls"]

    @property
    def cat_pictures_served(self):
        return self._metrics["cat_pictures_served"]
```

`@property` относится к  [декораторам](https://realpython.com/primer-on-python-decorators/). В этом случае декоратор позволяет получить доступ к `func_calls` и `cat_pictures_served`  как если бы они были атрибутами:

```python
>>> metrics = Metrics()
>>> metrics.func_calls
0
>>> metrics.cat_pictures_served
0
```

Факт доступа к именам как к атрибутам позволяет абстрагироваться от того факта, что эти значения в словаре. Также это делает более явным указывание какие имена у атрибутов. Конечно, должна быть возможность увеличивать эти значения:

```python
class Metrics(object):
    # ...

    def inc_func_calls(self):
        self._metrics["func_calls"] += 1

    def inc_cat_pics(self):
        self._metrics["cat_pictures_served"] += 1
```

Здесь представлены два новых метода:

1.  `inc_func_calls()`
2.  `inc_cat_pics()`

Эти методы изменяют значение переменных в метрике `dict`. Теперь имеем класс, который работает как измененный указатель:

```python
>>> metrics = Metrics()
>>> metrics.inc_func_calls()
>>> metrics.inc_func_calls()
>>> metrics.func_calls
2
```

Теперь возможен доступ  `func_calls` и вызов `inc_func_calls()` в различных местах приложения и симулирования указателей. Это полезно когда необходимо что-нибудь похожее на часто обновляемые метрики в разных частях приложения.

**Замечание:** в этом классе явное использование `inc_func_calls()` и `inc_cat_pics()` вместо `@property.setter`  предотвращает пользователям устанавливать  произвольные значения `int` или недопустимые значения типа `dict`.

Полный код для класса `Metrics`:

```python
class Metrics(object):
    def __init__(self):
        self._metrics = {
            "func_calls": 0,
            "cat_pictures_served": 0,
        }

    @property
    def func_calls(self):
        return self._metrics["func_calls"]

    @property
    def cat_pictures_served(self):
        return self._metrics["cat_pictures_served"]

    def inc_func_calls(self):
        self._metrics["func_calls"] += 1

    def inc_cat_pics(self):
        self._metrics["cat_pictures_served"] += 1
```

## Настоящие указатели с `ctypes`

Используя встроенный модуль `ctypes`, возможно создавать настоящие указатели в стиле C. Познакомиться с этим модулем можно здесь [Extending Python With C Libraries and the “ctypes” Module](https://dbader.org/blog/python-ctypes-tutorial)

Настоящая причина по которой необходимо использовать этот модуль, если необходимо вызвать функцию из библиотеки C, которая требует указатель. Вернемся к примеру  `add_one()` на языке C:

```python
void add_one(int *x) {
    *x += 1;
}
```

Этот код все так же увеличивает значение переменной `x` на единицу. Для это функции использования сначала скомпилируем  ее в динамическую библиотеку. Предполагается, что код хранится в файле `add.c`. Используем компилятор `gcc`:

```bash
$ gcc -c -Wall -Werror -fpic add.c
$ gcc -shared -o libadd1.so add.o
```

Первая команда компилирует исходник на C в объект называемый `add.o`. Вторая команда берет этот несвязанный файл библиотеки и создает динамическую библиотеку называемую `libadd1.so`.

 `libadd1.so` должен быть в текущей директории. Можно загрузить эту библиотеку в Python используя `ctypes`:

```python
>>> import ctypes
>>> add_lib = ctypes.CDLL("./libadd1.so")
>>> add_lib.add_one
<_FuncPtr object at 0x7f9f3b8852a0>
```



```python
>>> import ctypes
>>> add_lib = ctypes.CDLL("./libadd1.so")
>>> add_lib.add_one
<_FuncPtr object at 0x7f9f3b8852a0>
```

`ctypes.CDLL` вернет объект который представляет `libadd1` динамическую библиотеку. Так как `add_one()` определена в этой библиотеке, можно получить доступ к ней так же как к любому объекту Python. Однако перед вызовом функции необходимо указать ее сигнатуру. Это поможет Python убедиться что в функцию передан правильный тип.

В этом случае сигнатура функции это указатель на целое число. `ctypes` позволяет уточнить это, используя следующий код:

```python
>>> add_one = add_lib.add_one
>>> add_one.argtypes = [ctypes.POINTER(ctypes.c_int)]
```

В этом коде устанавливается сигнатура функции как этого ожидает C. Теперь, если попытаться вызвать этот код с неправильным типом, будет получено предупреждение вместо неопределенного поведения:

```python
>>> add_one(1)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ctypes.ArgumentError: argument 1: <class 'TypeError'>: \
expected LP_c_int instance instead of int
```

Python выбрасывает ошибку, объясняя, что `add_one()` хочет указатель вместо целого числа. К счастью, `ctypes` имеет возможность передать указатели этим функциям. Сначала  декларируем `ctypes`-целое число:

```python
>>> x = ctypes.c_int()
>>> x
c_int(0)
```

Этот код создает переменную `x` целого типа в C-стиле со значением равным `0`. `ctypes` предоставляет удобную функцию `byref()`, позволяющую передавать переменную по ссылке.

**Примечание:**  термин **по ссылке** противоположен передаче переменной **по значению**.

При передаче по ссылке передается ссылка на исходную переменную, таким образом, изменения значения переменной будут влиять и на исходную переменную. Передача по значению приводит к созданию копии исходной переменной, которые не будут связаны и изменения одной не будет влиять на значение другой переменной.

Для большего количества информации можно почитать [Pass by Reference in Python: Background and Best Practices](https://realpython.com/python-pass-by-reference/)

Все еще возможен вызов `add_one()`:

```python
>>> add_one(ctypes.byref(x))
998793640
>>> x
c_int(1)
```

Число было увеличено на единицу. Вот таким образом мы использовали реальные указатели в Python.     
