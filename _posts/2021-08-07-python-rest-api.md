---
title: "Python и REST API: взаимодействие с веб-сервисами"
date: 2021-08-10 00:00:00 -0000
toc: true
toc_sticky: true
excerpt_separator: "<!--more-->"
categories: 
  - Blog
tags:
  - python
  - API
  - REST API
  - DRF
  - Flask 
  - translation
  - tutorial
---

Множество **веб-сервисов**, такие как YouTube и GitHub дают доступ к своим данным через **программный интерфейс приложения (application programming interface (API))**. Один из самых популярных способов построения API это архитектурный стиль **REST**  (от [англ.](https://ru.wikipedia.org/wiki/Английский_язык) **Re**presentational **S**tate **T**ransfer — «передача состояния представления»). Python имеет не только инструменты для получения данных от REST API, но также инструменты для построения собственных REST API.

<!--more-->

**Этот пост покажет:**

- Что такое **REST-архитектура**
- Как **REST API** предоставляет доступ к веб-данным
- Как получать данные REST API используя библиотеку **requests**
- Построение REST API
- Какие популярные инструменты Python используются для построения REST API.

Используя Python и REST API можно извлекать, анализировать, обновлять и обрабатывать данные предоставляемые веб-сервисами.

[Оригинальный текст Python and REST APIs: Interacting With Web Services?](https://realpython.com/api-integration-in-python/)

## REST-архитектура

**REST** (от [англ.](https://ru.wikipedia.org/wiki/Английский_язык) ***Re**presentational **S**tate **T**ransfer* — «передача состояния представления») программный архитектурный стиль который определяет шаблоны для взаимодействия сервера и клиента по сети. REST предоставляет набор ограничений программной архитектуры для повышения производительности, масштабируемости, простоты и надежности систем.

REST определяет следующие ограничения архитектуры:

- **Отсутствие состояния:** сервер не сохраняет состояние между запросами от клиента.
- **Клиент-сервер:** клиент и сервер должны быть отделены друг от друга, позволяя разрабатывать их независимо.
- **Кэшируемость:** данные, извлеченные с сервера должны быть кэшированы либо клиентом, либо сервером.
- **Универсальный интерфейс:** сервер предоставляет универсальный интерфейс для доступа к ресурсам без определения их представления. 
- **Слои:** клиент может получить доступ к ресурсам сервера непрямо через промежуточные узлы, такие как прокси-серверы или балансировщик нагрузки.
- **Код по требованию (опционально):** сервер может передавать выполняемый код клиенту, такой как JavaScript для одностраничнорго приложения.

> **Примечание**, REST это не спецификация, а набор указаний для построения сетевых приложений.

## REST API и веб-сервисы

**REST веб-сервисы** это любой сервис, который придерживается REST-архитектуры. Эти сервисы предоставляют данные внешнему миру через API. REST API предоставляет доступ к данным веб-сервисов через публичные URL.

Например,  [GitHub’s REST API](https://docs.github.com/en/free-pro-team@latest/rest):

`https://api.github.com/users/<username>` 

Этот URL предоставляет информацию о GitHub пользователе. Вы получаете данные от REST API посылая HTTP-запрос к определенному URL и обрабатываете ответ.

### HTTP методы

REST API слушают HTTP-методы, такие как `GET`, `POST` и `DELETE` для определения операций над ресурсами. **Ресурсы** это любые доступные данные на веб-сервисе и управляемые **HTTP запросами** к REST API. HTTP метод говорит API какую операцию произвести над ресурсом.

Существуют множество HTTP методов, но перечисленные ниже пять методов наиболее часто используются REST API:

| HTTP метод | Описание                                    |
| ---------- | ------------------------------------------- |
| `GET`      | Получить существующий ресурс.               |
| `POST`     | Создание нового ресурса.                    |
| `PUT`      | Обновление существующего ресурса.           |
| `PATCH`    | Частичное обновление существующего ресурса. |
| `DELETE`   | Удалить ресурс.                             |

REST API клиентское приложение может использовать эти пять HTTP методы для управления состоянием ресурсов веб-сервиса.

### Коды состояния

Получив и обработав **HTTP запрос**, REST API возвращает **HTTP ответ**, в котором содержится **HTTP код статуса**. Этот код предоставляет информацию о результате запроса. Приложение, отправившее запрос к API может проверить код статуса и, в зависимости от результата, выполнить действия. Например, обработать ошибки или показать сообщение пользователю.

Список наиболее часто используемых кодов статуса возвращаемые REST API:

| Code  | Meaning                | Description                                                  |
| ----- | ---------------------- | ------------------------------------------------------------ |
| `200` | OK                     | Запрос успешен.                                              |
| `201` | Created                | Новый ресурс был создан.                                     |
| `202` | Accepted               | Запрос принят, но изменения еще не сделаны.                  |
| `204` | No Content             | Запрос успешен, но но ответ не содержит данных.              |
| `400` | Bad Request            | Запрос некорректный.                                         |
| `401` | Unauthorized           | Клиент не авторизован для выполнения запрошенных действий.   |
| `404` | Not Found              | Запрашиваемый ресурс не найден.                              |
| `415` | Unsupported Media Type | Формат данных запроса не поддерживается сервером.            |
| `422` | Unprocessable Entity   | Данные запроса правильно сформированы, но содержат недопустимые или отсутствующие данные. |
| `500` | Internal Server Error  | Сервер выдал ошибку при обработке запроса.                   |

Эти десять кодов статуса представляют только маленький набор поддерживаемых [HTTP кодов состояния](https://ru.wikipedia.org/wiki/Список_кодов_состояния_HTTP). Нумерация кодов состояния зависит от категории результата:

| Code range | Категория         |
| ---------- | ----------------- |
| `2xx`      | Успешная операция |
| `3xx`      | Перенаправление   |
| `4xx`      | Ошибка клиента    |
| `5xx`      | Ошибка сервера    |

Коды состояния пригодятся при работе с REST API для выполнения различной логики в зависимости от результата запроса.

### Конечные точки API 

REST API предоставляет набор публичных URL-адресов, которые клиентские приложения используют для доступа к ресурсам веб-сервиса. Эти URL-адреса в контексте API называются **конечными точками (endpoints) (далее КТ)**.

Чтобы разобраться, взлянем на таблицу. В ней показаны КТ для гипотетической CRM-системы. Эти КТ нужны для доступа к клиентским ресурсам, которые представляют потенциальных клиентов (`customers`) в системе:

| HTTP method | API endpoint               | Description                    |
| ----------- | -------------------------- | ------------------------------ |
| `GET`       | `/customers`               | Получить список клиентов.      |
| `GET`       | `/customers/<customer_id>` | Получить одного клиента по id. |
| `POST`      | `/customers`               | Создать нового клиента.        |
| `PUT`       | `/customers/<customer_id>` | Обновить клиента.              |
| `PATCH`     | `/customers/<customer_id>` | Частично обновить клиента.     |
| `DELETE`    | `/customers/<customer_id>` | Удалить клиента.               |

Каждая КТ представляет различные действия основанные на HTTP методе.

> **Примечание:** Базовый URL для конечных точек скрыта для краткости. В реальности полная строка URL доступа к конечной точке будет выглядеть вот так:
>
> ``````http
> https://api.example.com/customers
> ``````

Некоторые КТ имеют  `<customer_id>` в конце. Эта запись означает, что нужно добавить числовой `customer_id` в конце URL, чтобы сказать REST API с каким клиентов хотелось бы поработать.

Перечисленные выше КТ представляют только один ресурс в системе. Реальные REST API часто имеют десятки или сотни различных КТ для управления ресурсами веб-сервиса.

### REST и Python: использование API

Чтобы написать код, который взаимодействует с REST API, большинство разработчиков Python обращаются к библиотеке [`requests`](https://realpython.com/python-requests/) для отправки HTTP-запросов. Эта библиотека абстрагируется от сложностей выполнения HTTP-запросов. Это один из немногих проектов, ценность которого такая, как будто она включена в стандартные библиотеки (по состоянию на Python 3.9.6 не включена в стандартные библиотеки).

Чтобы начать использовать библиотеку `requests`, необходимо сначала установить ее:

`$ python -m pip install requests` 

После этого можно начать использовать `requests`.

### GET

`GET` один из наиболее часто использующихся при работе с REST API HTTP-методов. Этот метод позволяет получить ресурсы от API. `GET` это операция только для чтения (**read-only**), поэтому не стоит использовать ее для модификации существующих ресурсов.

Для тестирования `GET` и других методов в этом разделе, будем использовать сервис [JSONPlaceholder](https://jsonplaceholder.typicode.com/). Это бесплатный сервис предоставляет фейковые конечные точки API посылая ответы, которые `requests` может обработать.

Отправим `GET` запрос к JSONPlaceholder:

```python
>>> import requests
>>> JSONPlaceholder
>>> api_url = "https://jsonplaceholder.typicode.com/todos/1"
>>> response = requests.get(api_url)
>>> response.json()
{'userId': 1, 'id': 1, 'title': 'delectus aut autem', 'completed': False}

```

Этот код вызывает `requests.get()` для отправки `GET` запроса к `/todos/1`, который отвечает `todo` элементом с номером ID `1`. Далее вызывается [`.json()`](https://docs.python-requests.org/en/master/user/quickstart/#json-response-content) для объекта `response` для просмотра вернувшихся от API данных.

Вернувшиеся данные форматированы как [JSON](https://www.json.org/json-en.html), хранилище типа ключ-значение похожее на [словарь Python](https://realpython.com/python-dicts/). Это очень популярный формат данных и de facto формат обмена для большинства REST API.

Также можно посмотреть другие атрибуты `response`:

```python
>>> response.status_code
200
>>> response.headers["Content-Type"]
'application/json; charset=utf-8'
```

В первой строке код возвращает код состояния HTTP запроса. Во второй получаем значение по ключу Content-Type из словаря headers, который содержит метаданные о запросе.

### POST

Теперь взглянем на использование `requests` для отправки данных методом POST и создания нового ресурса. Снова используем JSONPlaceholder, но в этот раз включим JSON-данные в запрос:

```python
{
    "userId": 1,
    "title": "Buy milk",
    "completed": false
}
```

Этот JSON содержит информацию о новом `todo`. Выполним следующий код:

```python
>>> import requests
>>> api_url = "https://jsonplaceholder.typicode.com/todos"
>>> todo = {"userId": 1, "title": "Buy milk", "completed": False}
>>> response = requests.post(api_url, json=todo)
>>> response.json()
{'userId': 1, 'title': 'Buy milk', 'completed': False, 'id': 201}
```

Вызов `requests.post()` нужен для создания `todo` в системе.

В коде выше сначала создается словарь содержащий данные для нового `todo`. Затем этот словарь передается в ключевой аргумент `json` метода requests.post(). Когда это сделано, `requests.post()` автоматически устанавливает HTTP-заголовок запроса `Content-Type` в `application/json`. Также это сериализует `todo` в JSON строку, которая добавляется к телу запроса.

Возможно не использовать ключевой аргумент `json` для использования данных в JSON формате. Но тогда необходимо установить `Content-Type` и сериализовать JSON вручную. Следующий код использует описанный способ и является эквивалентным предыдущему способу: 

```python
>>> import requests
>>> import json 
>>> api_url = "https://jsonplaceholder.typicode.com/todos"
>>> todo = {"userId": 1, "title": "Buy milk", "completed": False}
>>> headers =  {"Content-Type":"application/json"} 
>>> response = requests.post(api_url, data=json.dumps(todo), headers=headers) 
>>> response.json()
{'userId': 1, 'title': 'Buy milk', 'completed': False, 'id': 201}
>>> response.status_code
201
```

В этом коде словарь `headers`, содержащий единственный заголовок `Content-Type` установленный в `application/json`.  Это говорит REST API, что мы посылаем JSON данные с запросом.

Затем вызывается `requests.post()`, но вместо передачи `todo` в аргумент `json`, сначала вызывается `json.dumps(todo)` для сериализации и передается в ключевой аргумент `data`, который говорит библиотеке `requests` какие данные включить в запрос. Также словарь `headers` передается в `requests.post()` для установки HTTP заголовков.

> **Примечание:** [`json.dumps()`](https://docs.python.org/3/library/json.html#json.dumps) пришла из пакета [`json`](https://docs.python.org/3/library/json.html) стандартной библиотеки. Этот пакет предоставляет полезные методы для работы с [JSON в Python](https://realpython.com/python-json/).

Когда requests.post() вызывается таким образом, получается тот же самый результат как в предыдущем коде, но в то же время такой способ дает больше контроля над запросом.

После ответа API, вызываем `response.json()` для вывода JSON, который содержит сгенерированный `id` для нового `todo`. Статус `201` говорит, что новый ресурс был создан.

### PUT

Нижеследующий код посылает `PUT` запрос для обновления существующего `todo` с новыми данными. Любые данные, посланные с `PUT` запросом, полностью заменят существующие данные `todo`.

Будем использовать ту же конечную точку JSONPlaceholder, которая была в `GET` и `POST` запросах, но в этот раз добавим `10` в конце URL. Это скажет REST API какое именно `todo` хотим обновить:

```python
>>> import requests
>>> api_url = "https://jsonplaceholder.typicode.com/todos/10"
>>> response = requests.get(api_url)
>>> response.json()
{'userId': 1, 'id': 10, 'title': 'illo est ... aut', 'completed': True}
>>> todo = {"userId": 1, "title": "Wash car", "completed": True} 
>>> response = requests.put(api_url, json=todo) 
>>> response.json() 
{'userId': 1, 'title': 'Wash car', 'completed': True, 'id': 10}
>>> response.status_code
200
```

В этом коде сначала вызываем `requests.get()`, чтобы увидеть содержимое существующего `todo`. Затем вызываем `requests.put()` с новыми JSON данными, чтобы заменить существующие `todo` значения. Новые значения можно увидеть после вызова `response.json()`. Успешный `PUT` запрос всегда возвращает код `200` вместо `201`, потому что не создается новый ресурс, а обновляется существующий.

### PATCH

Далее используем `requests.patch()` для изменения значений определенного поля существующего `todo`. `PATCH` отличается от `PUT` тем, что не полностью заменяет существующий ресурс, а только изменяет набор значений на значения из JSON, которые посылаются в запросе. 

Используем тот же `todo` из прошлого примера:

```python
{'userId': 1, 'title': 'Wash car', 'completed': True, 'id': 10}
```

Теперь обновим `title` новым значением:

```python
>>> import requests
>>> api_url = "https://jsonplaceholder.typicode.com/todos/10"
>>> todo = {"title": "Mow lawn"} 
>>> response = requests.patch(api_url, json=todo) 
>>> response.json()
{'userId': 1, 'id': 10, 'title': 'Mow lawn', 'completed': True}
>>> response.status_code
200
```

Видно, что после вызова `response.json()` изменилось только поле `title`.

### DELETE

Последнее, но не менее важное, если хочется полностью удалить ресурс, используется `DELETE`. Далее код для удаления определенного `todo`:

```python
>>> import requests
>>> api_url = "https://jsonplaceholder.typicode.com/todos/10"
>>> response = requests.delete(api_url)
>>> response.json()
{}
>>> response.status_code
200
```

Сначала вызывается `requests.delete()` с URL, содержащим ID определенного `todo`, которое собираемся удалить. Таким образом, посылается `DELETE` запрос к REST API. После удаления ресурса, API отвечает пустым JSON объектом, показывающим, что ресурс был удален.

## REST и Python: построение API

 Проектирование REST API обширная тема с множеством  уровней. Как и в большинстве технологий, существует множество мнений о лучшем подходе к построению API. В этой теме даются некоторые рекомендации по построению собственного API.

### Определение ресурсов

Первым шагом является определение ресурсов, которыми управляет API. Обычно ресурсы принято называть существительными во множественном числе, например, `customers`, `events`, `transactions`. По мере того, как вы определите различные ресурсы в вашем веб-сервисе, составляется список существительных которые описывают различные данные управляемые пользователями через API.

### Определение собственных конечных точек

Определившись с ресурсами, необходимо определиться с их конечными точками. Ниже показан пример конечных точек для ресурса `transactions`, который может использоваться в API платежного сервиса:  

| HTTP method | API endpoint                     | Description                    |
| ----------- | -------------------------------- | ------------------------------ |
| `GET`       | `/transactions`                  | Получить список транзакций.    |
| `GET`       | `/transactions/<transaction_id>` | Получить единичную транзакцию. |
| `POST`      | `/transactions`                  | Создать новую транзакцию.      |
| `PUT`       | `/transactions/<transaction_id>` | Обновить транзакцию.           |
| `PATCH`     | `/transactions/<transaction_id>` | Частично обновить транзакцию.  |
| `DELETE`    | `/transactions/<transaction_id>` | Удалить транзакцию.            |

Эти шесть КТ покрывают все операции по созданию, чтению, обновлению и удалению `transactions` в веб-сервисе. Каждый ресурс в вашем веб-сервисе будет иметь похожий список конечных точек, основанных на действиях с API которые может производить пользователь.

> **Примечание:** Конечная точка не должна содержать глаголов. Вместо этого следует выбрать соответствующие HTTP-методы для передачи действий конечной точке. Например, конечная точка содержит не нужный глагол:
>
> ```http
> GET /getTransactions
> ```
>
> `get` включен в конечную точку, хотя в этом нет необходимости. Метод `GET` уже предоставляет семантическое значение для конечной точки показывая действие. Можно убрать `get` из конечной точки:
>
> ```http
> GET /transactions
> ```
>
> Теперь взглянем на пример конечных точек для вложенных ресурсов. Здесь конечные точки для `guests` вложены в `events` ресурсы:

| HTTP метод | Конечная точка API                     | Описание                   |
| ---------- | -------------------------------------- | -------------------------- |
| `GET`      | `/events/<event_id>/guests`            | Получить список гостей.    |
| `GET`      | `/events/<event_id>/guests/<guest_id>` | Получить единичного гостя. |
| `POST`     | `/events/<event_id>/guests`            | Создать нового гостя.      |
| `PUT`      | `/events/<event_id>/guests/<guest_id>` | Обновить гостя.            |
| `PATCH`    | `/events/<event_id>/guests/<guest_id>` | Частично обновить гостя.   |
| `DELETE`   | `/events/<event_id>/guests/<guest_id>` | Удалить гостя.             |

С этими конечными точками можно управлять `guests` для определенного события в системе.

Это не единственный путь определения конечных точек для вложенных ресурсов. Некоторые люди предпочитают использовать [строки запроса](https://en.wikipedia.org/wiki/Query_string) для доступа к вложенным ресурсам. Строка запроса позволяет добавлять параметры к HTTP-запросу. В нижеследующем примере к URL добавляется строка запроса получения `guests` для определенного `event_id`:

```HTTP
HTTP
GET /guests?event_id=23
```

Эта конечная точка отфильтрует любых `guests` которые не относятся к данному `event_id`. Как и во множестве вещей в проектировании API, необходимо решить какие методы подходят для вашего сервиса.

> **Примечание:** Маловероятно, что ваш REST API сможет остаться неизменным в течение всего срока работы веб-сервиса. Ресурсы будут меняться и надо будет изменять конечные точки, чтобы отразить эти изменения. И тут врывается **API версионирование**. Версионирование позволяет модифицировать API без страха сломать существующие интеграции.
>
> Существует множество стратегий версионирования. Правильный выбор зависит от требований вашего API.  Вот некоторые популярные варианты:
>
> - [URI versioning](https://docs.microsoft.com/en-us/azure/architecture/best-practices/api-design#uri-versioning)
> - [HTTP header versioning](https://docs.microsoft.com/en-us/azure/architecture/best-practices/api-design#header-versioning)
> - [Query string versioning](https://docs.microsoft.com/en-us/azure/architecture/best-practices/api-design#query-string-versioning)
> - [Media type versioning](https://docs.microsoft.com/en-us/azure/architecture/best-practices/api-design#media-type-versioning) 
>
> Неважно какой способ версионирования вы выберете, ибо версионирование - важный шаг для адаптации к изменениям требований для поддержки существующих пользователей.

### Выбор формата обмена данными

Два популярных варианта форматирования данных веб-сервисов - [XML](https://ru.wikipedia.org/wiki/XML) и JSON. Традиционно, XML был очень популярным с [SOAP](https://en.wikipedia.org/wiki/SOAP) API, а JSON более популярен с REST API. Для сравнения, взглянем на пример ресурса `book` форматированный как XML и JSON.

Вот XML:

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<book>
    <title>Python Basics</title>
    <page_count>635</page_count>
    <pub_date>2021-03-16</pub_date>
    <authors>
        <author>
            <name>David Amos</name>
        </author>
        <author>
            <name>Joanna Jablonski</name>
        </author>
        <author>
            <name>Dan Bader</name>
        </author>
        <author>
            <name>Fletcher Heisler</name>
        </author>
    </authors>
    <isbn13>978-1775093329</isbn13>
    <genre>Education</genre>
</book>
```

XML использует ряд элементов для кодирования данных. Каждый элемент имеет открывающий и закрывающий тэги с данными между ними. Элементы могут быть вложены в другие элементы. В примере можно видеть, что несколько `<author>` вложены в `<authors>`.

Теперь взглянем на те же данные в JSON:

```json
{
    "title": "Python Basics",
    "page_count": 635,
    "pub_date": "2021-03-16",
    "authors": [
        {"name": "David Amos"},
        {"name": "Joanna Jablonski"},
        {"name": "Dan Bader"},
        {"name": "Fletcher Heisler"}
    ],
    "isbn13": "978-1775093329",
    "genre": "Education"
}
```

JSON хранит данные в виде пар ключ-значение, похоже как в словаре Python. Так же как XML, JSON может хранить данные любого уровня вложенности, что позволяет строить сложные модели.

Ни JSON, ни XML не лучше друг друга, но разработчики предпочитают JSON остальному для применения в REST API. Особенно это касается REST API для работы с фронтенд фреймворками как [React](https://reactjs.org/) или [Vue](https://vuejs.org/).

### Проектирование успешных ответов

После выбора формата данных необходимо решить, как отвечать на запросы HTTP. Все ответы из вашего REST API должны иметь похожий формат и включать корректный код состояния HTTP.

В этом разделе, взглянем на некоторые примеры HTTP ответов для гипотетического API, которое управляет инвентарем `cars`. Эти примеры дадут понимание как вы должны форматировать ответы API. Чтобы было понятнее, будем смотреть на чистые HTTP запросы и ответы вместо использования HTTP библиотек вроде `requests`.

Чтобы начать работу, взглянем на запрос `GET` к `cars`, который возвращает список `cars`:

```http
GET /cars HTTP/1.1
Host: api.example.com
```

Этот HTTP запрос состоит из четырех этапов:

1.  **`GET`** это тип метода HTTP.
2.  **`/cars`** это конечная точка API.
3.  **`HTTP/1.1`** это версия HTTP.
4.  **`Host: api.example.com`** это API хост.

Эти четыре этапа достаточно чтобы послать `GET` запрос к `/cars`. Теперь взглянем на ответ. Это API использует JSON как формат обмена данными:

```http
HTTP/1.1 200 OK
Content-Type: application/json
...
[
    {
        "id": 1,
        "make": "GMC",
        "model": "1500 Club Coupe",
        "year": 1998,
        "vin": "1D7RV1GTXAS806941",
        "color": "Red"
    },
    {
        "id": 2,
        "make": "Lamborghini",
        "model":"Gallardo",
        "year":2006,
        "vin":"JN1BY1PR0FM736887",
        "color":"Mauve"
    },
    {
        "id": 3,
        "make": "Chevrolet",
        "model":"Monte Carlo",
        "year":1996,
        "vin":"1G4HP54K714224234",
        "color":"Violet"
    }
]
```

API вернуло ответ, который содержит список `cars`. Понятно, что ответ был успешен из-за статуса `200 OK`. Ответ также имеет `Content-Type` заголовок установленный в `application/json`. Это говорит пользователю, что надо анализировать ответ как JSON.

> **Примечание:** Когда вы работаете с реальным API, HTTP заголовков будет намного больше, чем в примере. Эти заголовки отличаются между API, поэтому они не были включены в пример.

Важно всегда использовать корректный `Content-Type` заголовок в вашем ответе. Если вы посылаете JSON, тогда необходимо установить `Content-Type` в `application/json`. Если XML, то `application/xml`. Этот заголовок говорит пользователю как необходимо анализировать данные.

Также необходимо включить корректный код состояния в ваш ответ. Для любых успешных `GET` запросов необходимо вернуть `200 OK`. Это говорит пользователю, что запрос был обработан как ожидалось.

Взгляните на другой `GET` запрос, в этот раз один экземпляр автомобиля:

```http
GET /cars/1 HTTP/1.1
Host: api.example.com
```

Этот HTTP-запрос запрашивает у API автомобиль `1`. Далее следует ответ:

```http
HTTP/1.1 200 OK
Content-Type: application/json
...
{
    "id": 1,
    "make": "GMC",
    "model": "1500 Club Coupe",
    "year": 1998,
    "vin": "1D7RV1GTXAS806941",
    "color": "Red"
}
```

Этот ответ содержит единичный JSON объект в данными автомобиля. Так как это единичный объект, данные представлены не списком. Как и в предыдущем примере, статус ответа `200 OK`.

> **Примечание:** `GET` запрос никогда не должен изменять существующий ресурс. Если запрос содержит данные, тогда эти данные должны игнорироваться и API должен вернуть данные ресурса неизмененными.

Давайте проверим `POST` запрос для добавления нового автомобиля:

```http
POST /cars HTTP/1.1
Host: api.example.com
Content-Type: application/json

{
    "make": "Nissan",
    "model": "240SX",
    "year": 1994,
    "vin": "1N6AD0CU5AC961553",
    "color": "Violet"
}
```

Этот `POST` запрос включает JSON с данными для нового автомобиля. Он устанавливает заголовок `Content-Type` в `application/json` поэтому API знает тип содержимого в запросе. API создаст новый автомобиль из данных JSON.

Ответ на запрос:

```http
HTTP/1.1 201 Created
Content-Type: application/json
...
{
    "id": 4,
    "make": "Nissan",
    "model": "240SX",
    "year": 1994,
    "vin": "1N6AD0CU5AC961553",
    "color": "Violet"
}
```

Запрос включает копию `car` с новыми данными. Напомним, что на `PUT` запрос необходимо в ответ включать полный ресурс. Это же применимо к `PATCH` запросам:

```http
PATCH /cars/4 HTTP/1.1
Host: api.example.com
Content-Type: application/json

{
    "vin": "VNKKTUD32FA050307",
    "color": "Green"
}
```

`PATCH` запросы только обновляют часть данных ресурса. В запросе выше поля `vin` и `color` будут обновлены новыми значениями. Вот ответ:

```http
HTTP/1.1 200 OK
Content-Type: application/json

{
    "id": 4,
    "make": "Buick",
    "model": "Lucerne",
    "year": 2006,
 	"vin": "VNKKTUD32FA050307", 
 	"color": "Green" 
 }
```

Ответ содержит полную копию `car`. Видно, что поля `vin` и `color` обновились.

Наконец, посмотрим как ваш REST API должен отвечать когда принимает `DELETE` запрос. Пример `DELETE` запроса для удаления `car`:

```http
DELETE /cars/4 HTTP/1.1
```

Этот `DELETE` запрос просит API удалить `car` c ID равным `4`. Ответ на этот запрос:

```http
HTTP/1.1 204 No Content
```

Этот ответ содержит только код состояния `204 No Content`. Этот код говорит пользователю что операция была успешна, но нет содержимого для возврата. Это имеет смысл, так как `car` был удален и нет причин возвращать копию в ответе.

Запросы в примерах этого раздела работали как запланировано. Но что, если есть проблемы с запросом? В следующем разделе вы узнаете как REST API должно реагировать когда возникают ошибки.

### Проектирование ответов ошибок

Всегда есть шанс, что запросы к вашему REST API могут сбоить. Хорошая манера определить как будут выглядеть ошибочные запросы. Эти ответы кроме описания ошибок должны включать код статуса HTTP. В этом разделе будут показаны несколько примеров.

Посмотрим на запрос к ресурсу, который не существует в API:  

```http
GET /motorcycles HTTP/1.1
Host: api.example.com
```

Здесь пользователь посылает `GET` запрос к ресурсу `/motorcycle`, который не существует. API отвечает следующее:

```HTTP
HTTP/1.1 404 Not Found
Content-Type: application/json
...
{
    "error": "The requested resource was not found."
}
```

Этот ответ включает код состояния `404 Not Found`. Вместе с этим, ответ содержит JSON объект с описанием ошибки. Предоставление описания ошибки дает пользователю контекст ошибки.

Теперь взглянем на ответ ошибки, когда пользователь посылает неверный запрос: 

```http
POST /cars HTTP/1.1
Host: api.example.com
Content-Type: application/json

{
    "make": "Nissan",
    "year": 1994,
    "color": "Violet"
```

Этот `POST` запрос содержит данные JSON в некорректном формате.

В следующем примере пользователь посылает `POST` запрос, но включает неподдерживаемый формат содержимого:

```http
POST /cars HTTP/1.1
Host: api.example.com
Content-Type: application/xml

<?xml version="1.0" encoding="UTF-8" ?>
<car>
    <make>Nissan</make>
    <model>240SX</model>
    <year>1994</year>
    <vin>1N6AD0CU5AC961553</vin>
    <color>Violet</color>
</car>
```

В этом запросе  пользователь посылает XML, но API поддерживает только JSON. Ответ API:

```http
HTTP/1.1 415 Unsupported Media Type
Content-Type: application/json

{
    "error": "The application/xml mediatype is not supported."
}
```

Этот ответ включает код состояния `415 Unsupported Media Type`  показывающий, что `POST` запрос содержит формат данных, которые не поддерживаются API. Этот код ошибки работает в случае некорректного формата, но что если данные корректного формата некорректны сами по себе?

В этом примере пользователь посылает `POST` запрос, но данные `car` содержат поля несоответствующие API:

```http
POST /cars HTTP/1.1
Host: api.example.com
Content-Type: application/json

{
    "make": "Nissan",
    "model": "240SX",
 	"topSpeed": 120 "warrantyLength": 10 
}
```

В этом запросе пользователь добавил поля `topSpeed` и  `warrantyLength` в JSON. Эти поля не поддерживаются API, поэтому ответ будет следующий:

```http
HTTP/1.1 422 Unprocessable Entity
Content-Type: application/json

{
    "error": "Request had invalid or missing data."
}
```

Ответ содержит код статуса `422 Unprocessable Entity`. Этот код показывает, что проблем с запросом не было, но данные некорректны. REST API нужно валидировать входящие данные. Если пользователь посылает данные с запросом, тогда API должно валидировать данные и информировать пользователя о любых ошибках.

Ответы на ошибочные или успешные запросы  является одной из важнейших задач REST API. Если ваше API интуитивно понятно и предоставляет верные ответы, пользователям будеи проще создавать приложения вокруг веб-сервиса. К счастью, некоторые Python веб-фреймворки абстрагируют сложности обработки HTTP запросов и возврата ответов. В следующем разделе будут рассмотрены несколько популярных инструментов для построения REST API.

## REST и Python: инструментарий

В этом разделе будут описаны три популярных фреймворка для построения REST API в Python. Каждый фреймворк имеет плюсы и минусы, поэтому выбор более подходящего зависит от ваших потребностей. Для этого взглянем на REST API в каждом фреймворке. Все примеры будут показаны на API для управления коллекцией стран.

Каждая страна будет иметь следующие поля:

- **`name`** название страны
- **`capital`** столица страны.
- **`area`** площадь страны в квадратных километрах.

Поля `name`, `capital`, and `area` хранят данные об определенной стране в мире.

Большая чать данных высылаемых REST API берется из баз данных. Но работа с базами данных не относится к этому туториалу, поэтому для примеров будем использовать данные хранящиеся в списках (тип `list`) Python. Исключением будет пример с Django REST framework, который использует создаваемую Django базу данных SQLite.

> **Примечание:** Исходный код каждого примера лучше хранить в отдельных папках. Также можно использовать [виртуальные окружения](https://realpython.com/python-virtual-environments-a-primer/) для изоляции зависимостей.

Для согласованности, будем использовать `countries` как конечную очку для всех трех фреймворков. Также будем использовать JSON как формат данных для всех трех фреймворков.

### Flask

[Flask](https://realpython.com/introduction-to-flask-part-1-setting-up-a-static-site/) это микрофреймворк Python используемый для построения веб приложений и REST API. Flask обеспечивает основу для ваших приложений, оставляя большую вариативность разработки. Главная задача Flask - обрабатывать HTTP запросы и направлять их в соответствующую функцию приложения.

> **Примечание:** Код в этом разделе использует новый синтаксис [Flask 2](https://palletsprojects.com/blog/flask-2-0-released/). Если используете старую версию Flask, тогда пишите [`@app.route("/countries")`](https://flask.palletsprojects.com/en/2.0.x/api/#flask.Flask.route) вместо [`@app.get("/countries")`](https://flask.palletsprojects.com/en/2.0.x/api/#flask.Flask.get) и [`@app.post("/countries")`](https://flask.palletsprojects.com/en/2.0.x/api/#flask.Flask.post).
>
> Для обработки `POST` запросов в старых версиях [Flask](https://flask.palletsprojects.com/en/1.1.x/) понадобится добавить параметр `methods` в `@app.route()`:
>
> ```python
> @app.route("/countries", methods=["POST"])
> ```
>
> Этот маршрут обрабатывает `POST` запросы к `/countries`  в Flask 1.

Ниже пример приложения Flask для REST API:

```python
# app.py
from flask import Flask, request, jsonify

app = Flask(__name__)

countries = [
    {"id": 1, "name": "Thailand", "capital": "Bangkok", "area": 513120},
    {"id": 2, "name": "Australia", "capital": "Canberra", "area": 7617930},
    {"id": 3, "name": "Egypt", "capital": "Cairo", "area": 1010408},
]

def _find_next_id():
    return max(country["id"] for country in countries) + 1

@app.get("/countries")
def get_countries():
    return jsonify(countries)

@app.post("/countries")
def add_country():
    if request.is_json:
        country = request.get_json()
        country["id"] = _find_next_id()
        countries.append(country)
        return country, 201
    return {"error": "Request must be JSON"}, 415
```

Это приложение определяет конечную точку API `/countries` для управления списком стран. Оно обрабатывает два вида запросов:

1.  **`GET /countries`** возвращает `countries`.
2.  **`POST /countries`** добавляет новую `country` в список.

> **Примечание:** Это Flask приложение содержит функции для обработки только двух типов запросов к конечной точке `/countries`. В полноценном REST API должны быть функции для всех требуемых операций.

Чтобы запустить этот пример, необходимо установить `flask`:

```bash
$ python -m pip install flask
```

После того, как `flask` установлен, сохраните код в файл `app.py`. Чтобы запустить это приложение, сначала необходимо установить переменную среду `FLASK_APP` в `app.py`. Это скажет `Flask`, какой файл содержить приложение.

```bash
$ export FLASK_APP=app.py
```

Опционально, можно установить `FLASK_ENV` в `development`, что запустит Flask в отладочном режиме:

```bash
$ export FLASK_ENV=development
```

После того как переменные среды готовы, можно запустить сервер Flask вызвав `flask run`:

```bash
$ flask run
* Serving Flask app "app.py" (lazy loading)
* Environment: development
* Debug mode: on
* Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)
```

Если открыть в браузере адрес `http://127.0.0.1:5000/countries`, то отобразится ответ:

```python
[
    {
        "area": 513120,
        "capital": "Bangkok",
        "id": 1,
        "name": "Thailand"
    },
    {
        "area": 7617930,
        "capital": "Canberra",
        "id": 2,
        "name": "Australia"
    },
    {
        "area": 1010408,
        "capital": "Cairo",
        "id": 3,
        "name": "Egypt"
    }
]
```

Этот JSON ответ содержит три `countries` определенный в начале `app.py`. Посмотри на следующий код, чтобы понять как это работает:

``````
@app.get("/countries")
def get_countries():
    return jsonify(countries)
```

Этот код использует [декоратор](https://realpython.com/primer-on-python-decorators/) маршрута Flask `@app.get()` для подключения `GET` запросов к функции в приложении. При обращении к `/countries` Flask вызывает декорированную функцию для обработки HTTP запроса и возврата ответа.

`get_countries()` берет `countries` типа `list` и преобразует функцией `jsonify()` в JSON. Этот JSON возвращается в ответе.

> **Примечание:** В большинстве случаев можно просто вернуть словарь Python из функции Flask. Flask автоматически преобразует любой словарь Python в JSON. Это можно увидеть в коде:
>
> ```python
> @app.get("/country")
> def get_country():
>     return countries[1]
> ```
>
> В этом коде возварщается второй словарь из `countries`. Flask преобразует этот словарь в JSON. Ответ на запрос к `/country` будет следующим:
>
> ```python
> {
>     "area": 7617930,
>     "capital": "Canberra",
>     "id": 2,
>     "name": "Australia"
> }
> ```
>
> Это JSON версия словаря возвращаемый из `get_country()`.
>
> В `get_countries()` необходимо использовать `jsonify()`, потому что возвращается списко словарей, а не единичный словарь. Flask автоматически не преобразует списки в JSON.

Теперь взлянем на `add_country()`. Эта функция обрабатывает `POST` запросы к `/countries` и позволяет добавить новую страну в список. Она использует Flask [`request`](https://flask.palletsprojects.com/en/1.1.x/quickstart/#the-request-object) объект для получения информации о текущем HTTP запросе:

```python
@app.post("/countries")
def add_country():
    if request.is_json:
        country = request.get_json()
        country["id"] = _find_next_id()
        countries.append(country)
        return country, 201
    return {"error": "Request must be JSON"}, 415
```

Эта функция выполняет следующие операции:

1.  Использование [`request.is_json`](https://flask.palletsprojects.com/en/1.1.x/api/?highlight=is_json#flask.Request.is_json) для проверки запроса на JSON
2.  Создание экземпляра `country`  функцией `request.get_json()`
3.  Определение следующего `id` и установка его для `country`
4.  Добавление нового `country` к `countries`
5.  Возвращение `country` в ответе вместе с кодом состояния `201 Created`
6.  Возвращение кода состояния`415 Unsupported Media Type` если запрос не содержал JSON

`add_country()` also calls `_find_next_id()` to determine the `id` for the new `country`:

```python
def _find_next_id():
    return max(country["id"] for country in countries) + 1
```

Эта вспомогательная функция использует [генератор](https://realpython.com/introduction-to-python-generators/) для выбора всех ID и вызов `max()` для выбора максимального ID. Затем добавляется `1` чтобы получить новый ID.

Можно попробовать эту точку доступа в шелле используя инструмент [curl](https://curl.se/), которая позволяет отправлять HTTP запросы из командной строки и добавить новый `country` в список `countries`:

```bash
$ curl -i http://127.0.0.1:5000/countries \
-X POST \
-H 'Content-Type: application/json' \
-d '{"name":"Germany", "capital": "Berlin", "area": 357022}'

HTTP/1.0 201 CREATED
Content-Type: application/json
...

{
 "area": 357022,
 "capital": "Berlin",
 "id": 4,
 "name": "Germany"
}
```

`curl` команда имеет несколько опций, которые полезно знать:

- **`-X`** подготавливает HTTP метод для запроса.
- **`-H`** добавляет HTTP заголовок к запросу.
- **`-d`** устанавливает данные запроса.

С этими опциями curl посылает данные JSON в `POST` запрос с заголовком `Content-Type` установленным в `application/json`. REST API возвратит  `201 CREATED` вместе с JSON для добавленной страны.

> **Примечание:** В этом примере, `add_country()` не содержит валидации JSON на соотвествие  формату `countries`. Посмотрите [flask-expects-json](https://pypi.org/project/flask-expects-json/) если хотите валидировать формат JSON в Flask.

Вы можете использовать curl для отправки `GET` запроса к `/countries` для подтверждения что новый `country` был отправлен. Если не использовать `-X` в curl, тогда будет отправлен `GET` запрос по-умолчанию:

```python
$ curl -i http://127.0.0.1:5000/countries

HTTP/1.0 200 OK
Content-Type: application/json
...

[
 {
 "area": 513120,
 "capital": "Bangkok",
 "id": 1,
 "name": "Thailand"
 },
 {
 "area": 7617930,
 "capital": "Canberra",
 "id": 2,
 "name": "Australia"
 },
 {
 "area": 1010408,
 "capital": "Cairo",
 "id": 3,
 "name": "Egypt"
 },
 {
 "area": 357022,
 "capital": "Berlin",
 "id": 4,
 "name": "Germany"
 }
]
```

Это команда возвращает полный список стран в системе упорядоченными по очередности добавления.

Это просто пример того что Flask может. Это приложение может быть расширено включением конечных точек для других HTTP методов. Flask также имеет большую экосистему расширений для добавления функциональности REST API, такие как [интергацию с базами данных](https://realpython.com/flask-connexion-rest-api/), [аутентификацией](https://realpython.com/flask-google-login/), и фоновую обработку.

### Django REST Framework

Другой популярным выбором для построения REST API это Django REST framework - плагин который добавляет функциональность REST API к существующему Django проекту.

Если проект уже создан, просто примените шаблоны этого раздела. Если нет, то необходимо создать Django проект и подключить Django REST framework.

Сперва установите `Django`и `djangorestframework`:

```bash
$ python -m pip install Django djangorestframework
```

Теперь используйте инструмент `django-admin` для создания проекта Django:

```bash
$ django-admin startproject countryapi
```

Эта команда создаст новую папку в текущей директории под названием `countryapi`. Внутри этой папки есть все необходимые файлы для запуска проекта. Далее необходимо создать новое Django-приложение внутри проекта. Функциональность Django проекта разбивается на приложения. Каждое приложение управляет отдельной частью проекта.

Чтобы создать приложение в директории `countryapi` и запустите следующую команду:

```bash
$ python manage.py startapp countries
```

Это создаст новую папку `countries` внутри проекта. В папке находятся основные файлы для приложения.

После создания приложения, необходимо сказать Django об этом приложении. Рядом с только что  созданной папкой `country` есть другая папка `countryapi`. Папка содержит конфигурации и настройки проекта.

> **Примечание:** Папка имеет то же самое название как корневая папка, которую Django создал командой `django-admin startproject countryapi`.

Откройте файл `settings.py` внутри `countryapi` папки. Добавьте приложения `countries` и Django REST Framework (`rest_framework`) в файл настроек в список `INSTALLED_APPS` 

```python
# countryapi/settings.py
INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
 	"rest_framework",
 	"countries", ]
```

Добавление `rest_framework` в список приложений необходимо, потому что Django REST Framework это просто Django приложение. Django плагины и Django приложения это упакованные и распространяемые приложения Django, которые может использовать каждый.

Следующим шагом будет создание Django модели для определения полей ваших данных. Внутри приложения `countries` необходимо добавить строки:

```python
# countries/models.py
from django.db import models

class Country(models.Model):
	name = models.CharField(max_length=100) capital = models.CharField(max_length=100) 		area = models.IntegerField(help_text="(in square kilometers)")
```

Этот код определяет модель `Country`. Django будет использовать эту модель для создания таблиц базы данных и колонок для данных стран.

Для обновления базы данных и включения в нее модель `Country`:

```bash
$ python manage.py makemigrations
Migrations for 'countries':
 countries/migrations/0001_initial.py
 - Create model Country

$ python manage.py migrate
Operations to perform:
 Apply all migrations: admin, auth, contenttypes, countries, sessions
Running migrations:
 Applying contenttypes.0001_initial... OK
 Applying auth.0001_initial... OK
```

Эти команды используют [Django миграции](https://realpython.com/django-migrations-a-primer/) для создания новых таблиц в базе данных.

Эта таблица после создания будет пустой, поэтому ее надо заполнить данными для тестирования Django REST Framework. Для этого надо использовать Django фикстуры для загрузки данных в базу данных.

Скопируйте и сохраните следующие JSON данные в файл называющийся `countries.json` и сохраните в директорию `countries`:

```json
[
    {
        "model": "countries.country",
        "pk": 1,
        "fields": {
            "name": "Thailand",
            "capital": "Bangkok",
            "area": 513120
        }
    },
    {
        "model": "countries.country",
        "pk": 2,
        "fields": {
            "name": "Australia",
            "capital": "Canberra",
            "area": 7617930
        }
    },
    {
        "model": "countries.country",
        "pk": 3,
        "fields": {
            "name": "Egypt",
            "capital": "Cairo",
            "area": 1010408
        }
    }
]
```

Этот JSON содержит содержит записи базы данных для трех стран. Вызовите команду для загрузки этих данных в базу данных:

```bash
$ python manage.py loaddata countries.json
Installed 3 object(s) from 1 fixture(s)
```

После этого Django приложение готово и заполнено некоторыми данными. Теперь можно добавить Django REST framework в проект.

Django REST Framework берет существующую Django модель и преобразует в JSON для REST API. Он делает это с помощью **сериализаторов моделей**. Сериализатор моделей говорит Django REST Framework как преобразовывать экземпляр модели в JSON и какие данные включить.

Создадим сериализатор для модели `Country`. Сначала необходимо создать файл `serializers.py` внутри приложения `countries`. Когда это сделано, надо добавить следующий код в `serializers.py`:

```bash
# countries/serializers.py
from rest_framework import serializers
from .models import Country

class CountrySerializer(serializers.ModelSerializer):
    class Meta:
        model = Country
        fields = ["id", "name", "capital", "area"]
```

Сериализатор `CountrySerializer`, подкласс `serializers.ModelSerializer` автоматически генерирует JSON с данными основанными на полях модели `Country`. Подкласс `ModelSerializer` будет включать в JSON все поля из модели Django, если не указать в атрибуте `fields` список желаемых данных.

Так же как Django, Django REST Framework использует [views](https://docs.djangoproject.com/en/dev/topics/http/views/) для запроса данных из базы и отображения их пользователю. Вместо написания views с нуля, можно наследоваться от класса [`ModelViewSet`](https://www.django-rest-framework.org/api-guide/viewsets/#modelviewset), который имеет дефолтные views для стандартных REST API операций.

> **Примечание:** Django REST framework документация называет эти views как [actions](https://www.django-rest-framework.org/api-guide/viewsets/#viewset-actions).

Список действия, которые `ModelViewSet` и их эквивалентные HTTP-методы:

| HTTP method | Action              | Description                |
| ----------- | ------------------- | -------------------------- |
| `GET`       | `.list()`           | Получить списко стран.     |
| `GET`       | `.retrieve()`       | Получить единичную страну. |
| `POST`      | `.create()`         | Создать новую страну.      |
| `PUT`       | `.update()`         | Изменить страну.           |
| `PATCH`     | `.partial_update()` | Частично изменить страну.  |
| `DELETE`    | `.destroy()`        | Удалить страну.            |

Как видно, эти действия соответствуют стандартным HTTP методам ожидаемые от REST API. Можно [переопределить эти действия](https://www.django-rest-framework.org/api-guide/viewsets/#example) в подклассе или [добавить дополнительные действия](https://www.django-rest-framework.org/api-guide/viewsets/#marking-extra-actions-for-routing) основанные на требованиях к API.

Ниже написан код класса `CountryViewSet` наследованного от `ModelViewSet`. Этот класс генерируют views необходимые для управления данными `Country`. Добавьте этот код к `views.py` внутри приложения `countries`:

```python
# countries/views.py
from rest_framework import viewsets

from .models import Country
from .serializers import CountrySerializer

class CountryViewSet(viewsets.ModelViewSet):
    serializer_class = CountrySerializer
    queryset = Country.objects.all()
```

В этом классе `serializer_class` установлен в `CountrySerializer` и `queryset` установлен в `Country.objects.all()`. Это говорит Django REST Framework какой сериализатор использовать и как запрашивать данные из базы для определенного набора view.

После создания view, они должны быть сопоставлены с соответсвующими конечными точками (URL). Чтобы сделать это, Django REST Framework предоставляет `DefaultRouter` который автоматически генерирует URL для `ModelViewSet`.

Создайте файл urls.py в приложении `countries` и добавьте код в файл:

```python
# countries/urls.py
from django.urls import path, include
from rest_framework.routers import DefaultRouter

from .views import CountryViewSet

router = DefaultRouter()
router.register(r"countries", CountryViewSet)

urlpatterns = [
    path("", include(router.urls))
]
```

Этот код создает `DefaultRouter` и регистрирует `CountryViewSet` под URL `countries`. Это поместит все URL для `CountryViewSet` под `/countries/`.

> **Примечание:** Django REST Framework автоматически добавить прямой слэш (`/`) в конец любых конечных точек сгенерированных `DefaultRouter`. Можно отключить это поведение следующим образом:
>
> ```python
> router = DefaultRouter(trailing_slash=False)
> ```

Наконец, необходимо обновить основной файл `urls.py` включив в него все URL'ы `countries`.  Измените файл `urls.py` внутри папки `countryapi` :

```shell
# countryapi/urls.py
from django.contrib import admin
from django.urls import path, include 
urlpatterns = [
    path("admin/", admin.site.urls),
 	path("", include("countries.urls")), 
]
```

Это поместит все URL'ы в `/countries/`. Теперь вы готовы попробовать Django-backend REST API. Запустить сервер разработки Django в корневой директории `countryapi`:

```shell
$ python manage.py runserver
```

Сервер разрабоки запущен и можно послать `GET` запрос к `/countries/` чтобы получить список всех стран в Django проекте:

```bash
$ curl -i http://127.0.0.1:8000/countries/ -w '\n'

HTTP/1.1 200 OK
...

[
 {
 "id": 1,
 "name":"Thailand",
 "capital":"Bangkok",
 "area":513120
 },
 {
 "id": 2,
 "name":"Australia",
 "capital":"Canberra",
 "area":7617930
 },
 {
 "id": 3,
 "name":"Egypt",
 "capital":"Cairo",
 "area":1010408
 }
]
```

Ответ написанный здесь отформатирован для читаемости, ваш ответ будет выглядеть по-другому. Django REST Framework отправить обратно JSON ресурс с тремя странами, которые были написаны ранее.

 [`DefaultRouter`](https://www.django-rest-framework.org/api-guide/routers/#defaultrouter) созданный в `countries/urls.py` предоставляет URL'ы для запросов ко всем стандартным конечным точкам API:

- `GET /countries/`
- `GET /countries/<country_id>/`
- `POST /countries/`
- `PUT /countries/<country_id>/`
- `PATCH /countries/<country_id>/`
- `DELETE /countries/<country_id>/`

Можете попробовать еще несколько конечных точек. Пошлите `POST` запрос к `/countries/` для создания новой `Country` в проекте:

```bash
$ curl -i http://127.0.0.1:8000/countries/ \
-X POST \
-H 'Content-Type: application/json' \
-d '{"name":"Germany", "capital": "Berlin", "area": 357022}' \
-w '\n'

HTTP/1.1 201 Created
...

{
 "id":4,
 "name":"Germany",
 "capital":"Berlin",
 "area":357022
}
```

Это создаст новую запись `Country`. Django REST Framework возвратит код состояния `201 Created` и созданную `Country`.

> **Примечание:** По-умолчанию, ответ не включает в себя пустую строку в конце. Это означает, что вывод JSON в последней строке может попасть на приглашение командной строки. Чтобы этого не произошло, curl запускается с опцией `-w '\n'` для добавления новой строки в конце.

Можете посмотреть существующую Country посылая запрос `GET /countries/<country_id>/` с существующим `id`. Чтобы получить первую `Country` запустите следующую команду:

```
$ curl -i http://127.0.0.1:8000/countries/1/ -w '\n'

HTTP/1.1 200 OK
...

{
 "id":1,
 "name":"Thailand",
 "capital":"Bangkok",
 "area":513120
}
```

Ответ содержит информацию о первой стране. Эти примеры покрывают только `GET` и `POST` запросы. Попробуйте самостоятельно `PUT`, `PATCH`, and `DELETE` запросы чтобы увидеть, как можно полноценно управлять моделями из REST API.

 



```

```





```

```





```

```



```

```
